{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\contentful-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n/**\n * See <a href=\"https://www.contentful.com/developers/docs/concepts/sync/\">Synchronization</a> for more information.\n * @namespace Sync\n */\n\n\nimport { createRequestConfig, freezeSys, toPlainObject } from 'contentful-sdk-core';\nimport resolveResponse from 'contentful-resolve-response';\nimport mixinStringifySafe from './mixins/stringify-safe';\n/**\n * @memberof Sync\n * @typedef SyncCollection\n * @prop {Array<Entities.Entry>} entries - All existing entries on first sync. New and updated entries on subsequent syncs.\n * @prop {Array<Entities.Asset>} assets - All existing assets on first sync. New and updated assets on subsequent syncs.\n * @prop {Array<Sync.DeletedEntry>} deletedEntries - List of deleted Entries since last sync\n * @prop {Array<Sync.DeletedAsset>} deletedAssets - List of deleted Assets since last sync\n * @prop {string} nextSyncToken - Token to be sent to the next sync call\n * @prop {function(): Object} toPlainObject() - Returns this Sync collection as a plain JS object\n * @prop {function(?function=, space=): Object} stringifySafe(replacer,space) - Stringifies the Sync collection, accounting for circular references. Circular references will be replaced with just a Link object, with a <code>circular</code> property set to <code>true</code>. See <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\">MDN</a> and <a href=\"https://www.npmjs.com/package/json-stringify-safe\">json-stringify-safe</a> for more details on the arguments this method can take.\n */\n\n/**\n * Deleted Entries are the same as Entries, but only appear on the sync API.\n * @memberof Sync\n * @typedef DeletedEntry\n * @type Entities.Entry\n */\n\n/**\n * Deleted Assets are the same as Assets, but only appear on the sync API.\n * @memberof Sync\n * @typedef DeletedAsset\n * @type Entities.Asset\n */\n\n/**\n * This module retrieves all the available pages for a sync operation\n * @private\n * @param {Object} http - HTTP client\n * @param {Object} query - Query object\n * @param {Object} options - Sync options object\n * @param {boolean} [options.resolveLinks = true] - If links should be resolved\n * @param {boolean} [options.removeUnresolved = false] - If unresolvable links should get removed\n * @param {boolean} [options.paginate = true] - If further sync pages should automatically be crawled\n * @return {Promise<SyncCollection>}\n */\n\nexport default function pagedSync(_x, _x2) {\n  return _pagedSync.apply(this, arguments);\n}\n/**\n * @private\n * @param {Array<Entities.Entry|Entities.Array|Sync.DeletedEntry|Sync.DeletedAsset>} items\n * @return {Object} Entities mapped to an object for each entity type\n */\n\nfunction _pagedSync() {\n  _pagedSync = _asyncToGenerator(function* (http, query) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!query || !query.initial && !query.nextSyncToken && !query.nextPageToken) {\n      throw new Error('Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing');\n    }\n\n    if (query && query.content_type && !query.type) {\n      query.type = 'Entry';\n    } else if (query && query.content_type && query.type && query.type !== 'Entry') {\n      throw new Error('When using the `content_type` filter your `type` parameter cannot be different from `Entry`.');\n    }\n\n    const defaultOptions = {\n      resolveLinks: true,\n      removeUnresolved: false,\n      paginate: true\n    };\n\n    const {\n      resolveLinks,\n      removeUnresolved,\n      paginate\n    } = _objectSpread(_objectSpread({}, defaultOptions), options);\n\n    const syncOptions = {\n      paginate\n    };\n    const response = yield getSyncPage(http, [], query, syncOptions); // clones response.items used in includes because we don't want these to be mutated\n\n    if (resolveLinks) {\n      response.items = resolveResponse(response, {\n        removeUnresolved,\n        itemEntryPoints: ['fields']\n      });\n    } // maps response items again after getters are attached\n\n\n    const mappedResponseItems = mapResponseItems(response.items);\n\n    if (response.nextSyncToken) {\n      mappedResponseItems.nextSyncToken = response.nextSyncToken;\n    }\n\n    if (response.nextPageToken) {\n      mappedResponseItems.nextPageToken = response.nextPageToken;\n    }\n\n    return freezeSys(mixinStringifySafe(toPlainObject(mappedResponseItems)));\n  });\n  return _pagedSync.apply(this, arguments);\n}\n\nfunction mapResponseItems(items) {\n  const reducer = type => {\n    return (accumulated, item) => {\n      if (item.sys.type === type) {\n        accumulated.push(toPlainObject(item));\n      }\n\n      return accumulated;\n    };\n  };\n\n  return {\n    entries: items.reduce(reducer('Entry'), []),\n    assets: items.reduce(reducer('Asset'), []),\n    deletedEntries: items.reduce(reducer('DeletedEntry'), []),\n    deletedAssets: items.reduce(reducer('DeletedAsset'), [])\n  };\n}\n/**\n * If the response contains a nextPageUrl, extracts the sync token to get the\n * next page and calls itself again with that token.\n * Otherwise, if the response contains a nextSyncUrl, extracts the sync token\n * and returns it.\n * On each call of this function, any retrieved items are collected in the\n * supplied items array, which gets returned in the end\n * @private\n * @param {Object} http\n * @param {Array<Entities.Entry|Entities.Array|Sync.DeletedEntry|Sync.DeletedAsset>} items\n * @param {Object} query\n * @param {Object} options - Sync page options object\n * @param {boolean} [options.paginate = true] - If further sync pages should automatically be crawled\n * @return {Promise<{items: Array, nextSyncToken: string}>}\n */\n\n\nfunction getSyncPage(_x3, _x4, _x5, _x6) {\n  return _getSyncPage.apply(this, arguments);\n}\n/**\n * Extracts token out of an url\n * @private\n */\n\n\nfunction _getSyncPage() {\n  _getSyncPage = _asyncToGenerator(function* (http, items, query, _ref) {\n    let {\n      paginate\n    } = _ref;\n\n    if (query.nextSyncToken) {\n      query.sync_token = query.nextSyncToken;\n      delete query.nextSyncToken;\n    }\n\n    if (query.nextPageToken) {\n      query.sync_token = query.nextPageToken;\n      delete query.nextPageToken;\n    }\n\n    if (query.sync_token) {\n      delete query.initial;\n      delete query.type;\n      delete query.content_type;\n      delete query.limit;\n    }\n\n    const response = yield http.get('sync', createRequestConfig({\n      query: query\n    }));\n    const data = response.data || {};\n    items = items.concat(data.items || []);\n\n    if (data.nextPageUrl) {\n      if (paginate) {\n        delete query.initial;\n        query.sync_token = getToken(data.nextPageUrl);\n        return getSyncPage(http, items, query, {\n          paginate\n        });\n      }\n\n      return {\n        items: items,\n        nextPageToken: getToken(data.nextPageUrl)\n      };\n    } else if (data.nextSyncUrl) {\n      return {\n        items: items,\n        nextSyncToken: getToken(data.nextSyncUrl)\n      };\n    } else {\n      return {\n        items: []\n      };\n    }\n  });\n  return _getSyncPage.apply(this, arguments);\n}\n\nfunction getToken(url) {\n  const urlParts = url.split('?');\n  return urlParts.length > 0 ? urlParts[1].replace('sync_token=', '') : '';\n}","map":{"version":3,"sources":["C:/contentful-angular/node_modules/contentful/dist/es-modules/paged-sync.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","_toPropertyKey","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","createRequestConfig","freezeSys","toPlainObject","resolveResponse","mixinStringifySafe","pagedSync","http","query","options","initial","nextSyncToken","nextPageToken","Error","content_type","type","defaultOptions","resolveLinks","removeUnresolved","paginate","syncOptions","response","getSyncPage","items","itemEntryPoints","mappedResponseItems","mapResponseItems","reducer","accumulated","item","sys","entries","reduce","assets","deletedEntries","deletedAssets","_ref","sync_token","limit","get","data","concat","nextPageUrl","getToken","nextSyncUrl","url","urlParts","split","replace"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/**\n * See <a href=\"https://www.contentful.com/developers/docs/concepts/sync/\">Synchronization</a> for more information.\n * @namespace Sync\n */\nimport { createRequestConfig, freezeSys, toPlainObject } from 'contentful-sdk-core';\nimport resolveResponse from 'contentful-resolve-response';\nimport mixinStringifySafe from './mixins/stringify-safe';\n\n/**\n * @memberof Sync\n * @typedef SyncCollection\n * @prop {Array<Entities.Entry>} entries - All existing entries on first sync. New and updated entries on subsequent syncs.\n * @prop {Array<Entities.Asset>} assets - All existing assets on first sync. New and updated assets on subsequent syncs.\n * @prop {Array<Sync.DeletedEntry>} deletedEntries - List of deleted Entries since last sync\n * @prop {Array<Sync.DeletedAsset>} deletedAssets - List of deleted Assets since last sync\n * @prop {string} nextSyncToken - Token to be sent to the next sync call\n * @prop {function(): Object} toPlainObject() - Returns this Sync collection as a plain JS object\n * @prop {function(?function=, space=): Object} stringifySafe(replacer,space) - Stringifies the Sync collection, accounting for circular references. Circular references will be replaced with just a Link object, with a <code>circular</code> property set to <code>true</code>. See <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\">MDN</a> and <a href=\"https://www.npmjs.com/package/json-stringify-safe\">json-stringify-safe</a> for more details on the arguments this method can take.\n */\n\n/**\n * Deleted Entries are the same as Entries, but only appear on the sync API.\n * @memberof Sync\n * @typedef DeletedEntry\n * @type Entities.Entry\n */\n\n/**\n * Deleted Assets are the same as Assets, but only appear on the sync API.\n * @memberof Sync\n * @typedef DeletedAsset\n * @type Entities.Asset\n */\n\n/**\n * This module retrieves all the available pages for a sync operation\n * @private\n * @param {Object} http - HTTP client\n * @param {Object} query - Query object\n * @param {Object} options - Sync options object\n * @param {boolean} [options.resolveLinks = true] - If links should be resolved\n * @param {boolean} [options.removeUnresolved = false] - If unresolvable links should get removed\n * @param {boolean} [options.paginate = true] - If further sync pages should automatically be crawled\n * @return {Promise<SyncCollection>}\n */\nexport default async function pagedSync(http, query) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!query || !query.initial && !query.nextSyncToken && !query.nextPageToken) {\n    throw new Error('Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing');\n  }\n  if (query && query.content_type && !query.type) {\n    query.type = 'Entry';\n  } else if (query && query.content_type && query.type && query.type !== 'Entry') {\n    throw new Error('When using the `content_type` filter your `type` parameter cannot be different from `Entry`.');\n  }\n  const defaultOptions = {\n    resolveLinks: true,\n    removeUnresolved: false,\n    paginate: true\n  };\n  const {\n    resolveLinks,\n    removeUnresolved,\n    paginate\n  } = _objectSpread(_objectSpread({}, defaultOptions), options);\n  const syncOptions = {\n    paginate\n  };\n  const response = await getSyncPage(http, [], query, syncOptions);\n  // clones response.items used in includes because we don't want these to be mutated\n  if (resolveLinks) {\n    response.items = resolveResponse(response, {\n      removeUnresolved,\n      itemEntryPoints: ['fields']\n    });\n  }\n  // maps response items again after getters are attached\n  const mappedResponseItems = mapResponseItems(response.items);\n  if (response.nextSyncToken) {\n    mappedResponseItems.nextSyncToken = response.nextSyncToken;\n  }\n  if (response.nextPageToken) {\n    mappedResponseItems.nextPageToken = response.nextPageToken;\n  }\n  return freezeSys(mixinStringifySafe(toPlainObject(mappedResponseItems)));\n}\n\n/**\n * @private\n * @param {Array<Entities.Entry|Entities.Array|Sync.DeletedEntry|Sync.DeletedAsset>} items\n * @return {Object} Entities mapped to an object for each entity type\n */\nfunction mapResponseItems(items) {\n  const reducer = type => {\n    return (accumulated, item) => {\n      if (item.sys.type === type) {\n        accumulated.push(toPlainObject(item));\n      }\n      return accumulated;\n    };\n  };\n  return {\n    entries: items.reduce(reducer('Entry'), []),\n    assets: items.reduce(reducer('Asset'), []),\n    deletedEntries: items.reduce(reducer('DeletedEntry'), []),\n    deletedAssets: items.reduce(reducer('DeletedAsset'), [])\n  };\n}\n\n/**\n * If the response contains a nextPageUrl, extracts the sync token to get the\n * next page and calls itself again with that token.\n * Otherwise, if the response contains a nextSyncUrl, extracts the sync token\n * and returns it.\n * On each call of this function, any retrieved items are collected in the\n * supplied items array, which gets returned in the end\n * @private\n * @param {Object} http\n * @param {Array<Entities.Entry|Entities.Array|Sync.DeletedEntry|Sync.DeletedAsset>} items\n * @param {Object} query\n * @param {Object} options - Sync page options object\n * @param {boolean} [options.paginate = true] - If further sync pages should automatically be crawled\n * @return {Promise<{items: Array, nextSyncToken: string}>}\n */\nasync function getSyncPage(http, items, query, _ref) {\n  let {\n    paginate\n  } = _ref;\n  if (query.nextSyncToken) {\n    query.sync_token = query.nextSyncToken;\n    delete query.nextSyncToken;\n  }\n  if (query.nextPageToken) {\n    query.sync_token = query.nextPageToken;\n    delete query.nextPageToken;\n  }\n  if (query.sync_token) {\n    delete query.initial;\n    delete query.type;\n    delete query.content_type;\n    delete query.limit;\n  }\n  const response = await http.get('sync', createRequestConfig({\n    query: query\n  }));\n  const data = response.data || {};\n  items = items.concat(data.items || []);\n  if (data.nextPageUrl) {\n    if (paginate) {\n      delete query.initial;\n      query.sync_token = getToken(data.nextPageUrl);\n      return getSyncPage(http, items, query, {\n        paginate\n      });\n    }\n    return {\n      items: items,\n      nextPageToken: getToken(data.nextPageUrl)\n    };\n  } else if (data.nextSyncUrl) {\n    return {\n      items: items,\n      nextSyncToken: getToken(data.nextSyncUrl)\n    };\n  } else {\n    return {\n      items: []\n    };\n  }\n}\n\n/**\n * Extracts token out of an url\n * @private\n */\nfunction getToken(url) {\n  const urlParts = url.split('?');\n  return urlParts.length > 0 ? urlParts[1].replace('sync_token=', '') : '';\n}"]},"metadata":{},"sourceType":"module"}